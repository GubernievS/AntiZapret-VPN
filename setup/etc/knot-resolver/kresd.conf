-- Knot DNS Resolver configuration in -*- lua -*-
-- Refer to manual: https://www.knot-resolver.cz/documentation/stable

local min_ttl = 300			-- Minimum TTL in seconds
local max_ttl = 86400		-- Maximum TTL in seconds
local negative_ttl = 10800	-- Negative TTL in seconds

local systemd_instance = os.getenv('SYSTEMD_INSTANCE')

local function match_query_type(action, target_qtype)
	return function (state, query)
		if query.stype == target_qtype then
			-- filter matched the query, return action function
			return action
		else
			-- filter did not match, continue with next filter
			return nil
		end
	end
end

if string.match(systemd_instance, '^1') then

	-- Network interface configuration
	net.listen('10.29.0.1', 53, {kind = 'dns', freebind = true})
	net.listen('10.29.4.1', 53, {kind = 'dns', freebind = true})
	net.listen('10.29.8.1', 53, {kind = 'dns', freebind = true})

	-- Switch to unprivileged user
	user('knot-resolver', 'knot-resolver')

	-- Clear cache upon restart
	os.execute('rm -rf /var/cache/knot-resolver/*')

	-- Open cache and set size
	cache.open(100 * MB, 'lmdb:///var/cache/knot-resolver')

	-- Load useful modules
	modules = {
		'view'													-- Views for certain clients
		,'predict'												-- Prefetch expiring/frequent records
		,renumber = dofile('/etc/knot-resolver/renumber.lua')	-- IP address renumbering
		,'serve_stale < cache'									-- Using timed-out records if upstream is down
		,'fallback_tcp'											-- Fallback to TCP if UDP connection failed
	}

	-- Bind hostname to gateway IPv4
	view:addr('10.29.0.1/22', policy.domains(policy.ANSWER({[kres.type.A] = {rdata = kres.str2ip('10.29.0.1'), ttl = min_ttl}}), {todname(hostname())}))
	view:addr('10.29.4.1/22', policy.domains(policy.ANSWER({[kres.type.A] = {rdata = kres.str2ip('10.29.4.1'), ttl = min_ttl}}), {todname(hostname())}))
	view:addr('10.29.8.1/24', policy.domains(policy.ANSWER({[kres.type.A] = {rdata = kres.str2ip('10.29.8.1'), ttl = min_ttl}}), {todname(hostname())}))

	-- Return a link-local IPv6 response for AAAA queries
	policy.add(match_query_type(policy.ANSWER({[kres.type.AAAA] = {rdata = kres.str2ip('fe80::1'), ttl = max_ttl}}), kres.type.AAAA))

	-- Return an empty response for HTTPS queries
	policy.add(match_query_type(policy.ANSWER({[kres.type.SOA] = {rdata = kres.parse_rdata({'SOA . . 1 1 1 1 ' .. max_ttl}), ttl = max_ttl}}, true), kres.type.HTTPS))

	-- Return an empty response for SVCB queries
	policy.add(match_query_type(policy.ANSWER({[kres.type.SOA] = {rdata = kres.parse_rdata({'SOA . . 1 1 1 1 ' .. max_ttl}), ttl = max_ttl}}, true), kres.type.SVCB))

	-- Response policy zones and optional blocking ads, trackers, malware and phishing websites
	policy.add(policy.rpz(policy.ANSWER({[kres.type.A] = {rdata = kres.str2ip('169.254.0.1'), ttl = negative_ttl}}), '/etc/knot-resolver/deny.rpz', true))

	-- Resolve blocked domains using proxy.py
	policy.add(policy.rpz(policy.STUB('127.0.0.2'), '/etc/knot-resolver/proxy.rpz', true))

	-- Disable EDNS in upstream DNS queries
	policy.add(policy.all(policy.FLAGS('NO_EDNS')))

	-- Resolve OpenNIC, Emercoin and Namecoin domains
	policy.add(
		policy.suffix(
			policy.FORWARD({'94.247.43.254', '95.216.99.249', '152.53.15.127', '185.226.181.19'}),
			policy.todnames({'bbs.', 'chan.', 'cyb.', 'dyn.', 'epic.', 'geek.', 'gopher.',
							'indy.', 'libre.', 'neo.', 'null.', 'o.', 'oss.', 'oz.',
							'parody.', 'pirate.', 'free.', 'bazar.', 'coin.', 'emc.',
							'lib.', 'fur.', 'bit.', 'ku.', 'te.', 'ti.', 'uu.'})
		)
	)

	-- Resolve non-blocked domains
	policy.add(policy.all(policy.FORWARD({'62.76.76.62', '62.76.62.76', '195.208.4.1', '195.208.5.1'})))

elseif string.match(systemd_instance, '^2') then

	-- Network interface configuration
	net.listen('127.0.0.1', 53, {kind = 'dns', freebind = true})
	net.listen('10.28.0.1', 53, {kind = 'dns', freebind = true})
	net.listen('10.28.4.1', 53, {kind = 'dns', freebind = true})
	net.listen('10.28.8.1', 53, {kind = 'dns', freebind = true})

	-- Switch to unprivileged user
	user('knot-resolver', 'knot-resolver')

	-- Clear cache upon restart
	os.execute('rm -rf /var/cache/knot-resolver2/*')

	-- Open cache and set size
	cache.open(100 * MB, 'lmdb:///var/cache/knot-resolver2')

	-- Load useful modules
	modules = {
		'view'													-- Views for certain clients
		,'predict'												-- Prefetch expiring/frequent records
		,renumber = dofile('/etc/knot-resolver/renumber2.lua')	-- IP address renumbering
		,'serve_stale < cache'									-- Using timed-out records if upstream is down
		,'fallback_tcp'											-- Fallback to TCP if UDP connection failed
	}

	-- Bind hostname to gateway IPv4
	view:addr('10.28.0.1/22', policy.domains(policy.ANSWER({[kres.type.A] = {rdata = kres.str2ip('10.28.0.1'), ttl = min_ttl}}), {todname(hostname())}))
	view:addr('10.28.4.1/22', policy.domains(policy.ANSWER({[kres.type.A] = {rdata = kres.str2ip('10.28.4.1'), ttl = min_ttl}}), {todname(hostname())}))
	view:addr('10.28.8.1/24', policy.domains(policy.ANSWER({[kres.type.A] = {rdata = kres.str2ip('10.28.8.1'), ttl = min_ttl}}), {todname(hostname())}))

	-- Return a link-local IPv6 response for AAAA queries
	policy.add(match_query_type(policy.ANSWER({[kres.type.AAAA] = {rdata = kres.str2ip('fe80::1'), ttl = max_ttl}}), kres.type.AAAA))

	-- Return an empty response for HTTPS queries
	policy.add(match_query_type(policy.ANSWER({[kres.type.SOA] = {rdata = kres.parse_rdata({'SOA . . 1 1 1 1 ' .. max_ttl}), ttl = max_ttl}}, true), kres.type.HTTPS))

	-- Return an empty response for SVCB queries
	policy.add(match_query_type(policy.ANSWER({[kres.type.SOA] = {rdata = kres.parse_rdata({'SOA . . 1 1 1 1 ' .. max_ttl}), ttl = max_ttl}}, true), kres.type.SVCB))

	-- Response policy zones
	policy.add(policy.rpz(policy.ANSWER({[kres.type.A] = {rdata = kres.str2ip('169.254.0.1'), ttl = negative_ttl}}), '/etc/knot-resolver/deny2.rpz', true))

	-- Disable EDNS in upstream DNS queries
	policy.add(policy.all(policy.FLAGS('NO_EDNS')))

	-- Resolve OpenNIC, Emercoin and Namecoin domains
	policy.add(
		policy.suffix(
			policy.FORWARD({'94.247.43.254', '95.216.99.249', '152.53.15.127', '185.226.181.19'}),
			policy.todnames({'bbs.', 'chan.', 'cyb.', 'dyn.', 'epic.', 'geek.', 'gopher.',
							'indy.', 'libre.', 'neo.', 'null.', 'o.', 'oss.', 'oz.',
							'parody.', 'pirate.', 'free.', 'bazar.', 'coin.', 'emc.',
							'lib.', 'fur.', 'bit.', 'ku.', 'te.', 'ti.', 'uu.'})
		)
	)

	-- Resolve blocked domains
	policy.add(policy.all(policy.FORWARD({'1.1.1.1', '1.0.0.1', '9.9.9.10', '149.112.112.10'})))

else panic('Use kresd@1 or kresd@2 instance names')

end

-- Disable DNSSEC validation
trust_anchors.remove('.')

-- Disable using IPv6 for contacting upstream DNS
net.ipv6 = false

-- Set minimum and maximum TTL cache in seconds
cache.min_ttl(min_ttl)
cache.max_ttl(max_ttl)

-- Disable unused modules
modules.unload('refuse_nord')
modules.unload('validate')
modules.unload('ta_update')
modules.unload('ta_signal_query')
modules.unload('ta_sentinel')
modules.unload('detect_time_skew')
modules.unload('extended_error')
modules.unload('priming')
modules.unload('edns_keepalive')
modules.unload('detect_time_jump')

-- Uncomment only for debugging or logging DNS requests
--log_level('debug')